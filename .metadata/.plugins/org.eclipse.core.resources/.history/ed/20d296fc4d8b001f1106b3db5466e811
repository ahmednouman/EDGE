#include "hardware_init.h"
#include "stm32f4xx_it.h"

#include "circular_buffer.h"
#include "logging.h"


extern TaskHandle_t adcTaskHandle;

extern SemaphoreHandle_t xSemaphoreLogging;
extern SemaphoreHandle_t xMutexSpeed;
extern circ_buf speedBuffer;

static uint16_t lastCaptureTime = 0;
static uint16_t period = 0;
static uint16_t overflowCount = 0;

extern PCD_HandleTypeDef hpcd_USB_OTG_FS;
extern TIM_HandleTypeDef htim1;


void NMI_Handler(void)
{

   while (1)
  {
  }

}


void HardFault_Handler(void)
{
  LOG(LOG_CRITICAL, "HarFault");
  while (1)
  {

  }
}


void MemManage_Handler(void)
{
  LOG(LOG_CRITICAL, "Memory Manage ISSUE");
  while (1)
  {

  }
}


void BusFault_Handler(void)
{
  LOG(LOG_CRITICAL, "Bus Fault");
  while (1)
  {

  }
}

void UsageFault_Handler(void)
{
  LOG(LOG_CRITICAL, "Usage Fault");
  while (1)
  {

  }
}


void DebugMon_Handler(void)
{

}


void ADC_IRQHandler(void)
{
  HAL_ADC_IRQHandler(&hadc1);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == TIM1) {
    HAL_IncTick();
  }
  if (htim == &htim10) {
      overflowCount++;
  }
}

void TIM1_UP_TIM10_IRQHandler(void)
{
  HAL_TIM_IRQHandler(&htim1);
  HAL_TIM_IRQHandler(&htim10);
}


void EXTI15_10_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
}


void OTG_FS_IRQHandler(void)
{
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
}


void DMA2_Stream6_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_usart6_tx);
}


void USART6_IRQHandler(void)
{
  HAL_UART_IRQHandler(&huart6);
}

//void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
//{
//    if (GPIO_Pin == GPIO_PIN_12)
//    {
//        uint16_t currentTime = __HAL_TIM_GET_COUNTER(&htim10);
//
//        if (currentTime >= lastCaptureTime)
//        {
//            period = currentTime - lastCaptureTime;
//        }
//        else
//        {
//            period = (0xFFFF - lastCaptureTime) + currentTime + 1;
//        }
//
//        lastCaptureTime = currentTime;
//
//        if (xSemaphoreTakeFromISR(xMutexSpeed, NULL) == pdTRUE) {
//        	lifoPush(&speedBuffer, period);
//            xSemaphoreGiveFromISR(xMutexSpeed, NULL);
//        }
//
//    }
//}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_12)
    {
        uint16_t currentTime = __HAL_TIM_GET_COUNTER(&htim10);
        uint16_t lastOverflowCount = 0;

        if (overflowCount == lastOverflowCount) {
            if (currentTime >= lastCaptureTime) {
                period = currentTime - lastCaptureTime;
            } else {
                period = (0xFFFF - lastCaptureTime) + currentTime + 1;
            }
        } else {
            period = (0xFFFF - lastCaptureTime) + currentTime + 1;
            period += (overflowCount - lastOverflowCount - 1) * 0xFFFF;
        }

        // Update the last capture time and overflow count
        lastCaptureTime = currentTime;
        lastOverflowCount = overflowCount;

        // Reset overflow count to avoid indefinite growth
        overflowCount = 0;

        // Push the period to the buffer with mutex protection
        if (xSemaphoreTakeFromISR(xMutexSpeed, NULL) == pdTRUE) {
            lifoPush(&speedBuffer, period);
            xSemaphoreGiveFromISR(xMutexSpeed, NULL);
        }
    }
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    if (hadc->Instance == ADC1) {

        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        xTaskNotifyFromISR(
        	adcTaskHandle,
            0x01,
            eSetBits,
            &xHigherPriorityTaskWoken
        );

        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}


void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == huart6.Instance) {
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        xSemaphoreGiveFromISR(xSemaphoreLogging, &xHigherPriorityTaskWoken);

        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}
